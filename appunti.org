* Advent Of Code 2021

  I think it's time to blow this thing

  Get everybody and their stuff together

  Okay 3-2-1

  Let's jam... (cit)

** Day 1

*** Parte 1
    Prima parte molto semplice:
    1) il primo elemento viene assegnato alla variabile prev (previous,
       precedente).
    2) iteriamo dal secondo elemento all'ultimo confrontandolo con il
       prev e incrementando count se necessario.
    3) alla fine di ogni iterazione assegniamo a prev il valore
       corrente.

    Lo pseudo codice è il seguente:

    #+BEGIN_SRC python
    count = 0
    prev = depths[0]
      for cur in depths[1:]:
	 if prev < cur:
		 count += 1
	 prev = cur
    print(count)
    #+END_SRC

*** Parte 2
    Seconda parte abbastanza semplice, osservando che si tratta dello
    stesso algoritmo precedente ma applicato alla somma di tre elementi
    consecutivi.

    Possiamo calcolare la somma dei tre elementi con due loop annidati.

    Oppure possiamo calcolare solo la prima somma e aggiustarla con
    un'addizione e una sottrazione per ogni elemento successivo:

    #+BEGIN_EXAMPLE
    sum(i+1) = sum(i) - elemento(i + 3) - elemento(i)
    #+END_EXAMPLE

    Per un totale di n-2 somme.

    Ad un esame più approfondito noto che lo stesso ragionamento si
    può applicare per risolvere la parte 1, se la somma iniziale è di
    un solo elemento.

    Quindi possiamo usare lo stesso identico codice per entrambi i
    casi.

** Day2


*** Parte 1
    La prima parte è semplice, si tratta di interpretare correttamente
    tre istruzioni.

    La difficoltà maggiore è nel parsing dei dati: in python leggiamo
    il file intero con f.read()

    Applicando alla stringa ottenuta .splitlines() lo suddividiamo in
    linee.

    Dividiamo ogni stringa in due stringhe separate delimitate da spazi
    con .split().

    La prima stringa resta com'è, la seconda viene convertita in un
    numero intero. Codice Python:

    #+BEGIN_SRC python
    [(x[0], int(x[1])) for x in (x.split() for x in f.read().splitlines())]
    #+END_SRC

*** Parte 2
    La seconda parte è una variazione della prima con la modifica
    semantica delle istruzioni. Senza astrarre inutilmente il codice
    creo una funzione di interpretazione delle istruzioni diversa per
    ciascuna parte da risolvere.

** Day 3

   Problema abbastanza noioso, sarà per via del wall-of-text?
   Insomma.

   Questi problemi dell'AoC che sembrano completamente artificiali
   sono risolti di solito da qualche algoritmo famoso che in questo
   caso mi sfugge.

   Avendo a che fare con il conteggio dei bit forse è collegato a
   qualche sistema di error-correction.

   Lo risolvo solo in python per il momento.

** Day 4
*** Parte 1

    Abbiamo una lista di numeri e delle schede del bingo da caricare
    in memoria e dobbiamo anche tenere traccia di quali numeri della
    scheda sono stati estratti.

    Il problema principale è determinare la struttura dati più adatta
    per rappresentare le schede e per risolvere il problema.

    Per la lista dei numeri la struttura è semplicemente un array.

    Per le schede proviamo ad usare due array:
    1) un array con 25 numeri per rappresentare i numeri sulla scheda.
    2) un array con 25 bool per segnare se il numero alla posizione
       corrispondente è stato estratto.

    Per mappare la posizione (x, y) => pos usiamo la formula:

    #+BEGIN_EXAMPLE
    pos = y * 5 + x
    #+END_EXAMPLE

    Viceversa per pos => (x, y):

    #+BEGIN_EXAMPLE
    x = pos % 5
    y = pos // 5
    #+END_EXAMPLE

    Ogni scheda inoltre ha un campo won che segnala se è già vincente:
    in questo caso anche se marchiamo un numero non è necessario
    ricalcolare se la scheda ha vinto.

    Una funzione mark(board, n) cerca nella scheda il numero n e se lo
    trova lo segna come estratto.

    Possiamo creare un'altra funzione check(board) per vedere se la
    scheda è vincente. Così facendo però dovremmo visitare tutte le
    colonne e tutte le righe.

    Invece possiamo effettuare il check solo sull'ultimo numero che è
    stato estratto, controllando la riga e la colonna cui appartiene.

    E' meglio quindi fondere mark() e check() in un'unica funzione
    mark_and_check() che:
    1) controlla se il numero è presente nella scheda e lo segna
       estratto.
    2) controlla se la riga del numero estratto è stata tutta estratta
    3) controlla se la colonna del numero estratto è stata tutta
       estratta
    4) restituisce un bool che indica se la scheda è vincente.

    In particolare il seguente codice python:

    #+BEGIN_SRC python
      self.won = self.won \
	  or self.check_row(pos) \
	  or self.check_column(pos)
    #+END_SRC

    sfrutta il cosiddetto short-circuiting dell'operatore *or*: se la
    prima condizione (self.won) è già *True* non elabora le condizioni
    successive.

    Per il calcolo dei punti (score) la struttura dei dati scelta
    risulta adatta: basta iterare per ogni numero della scheda,
    controllare se non è stato marcato e quindi sommarlo.

*** Parte 2

    Basta semplicemente eliminare dalla lista delle schede ogni scheda
    vincente finché non ne resta una sola. A questo punto si arriva al
    numero che fa vincere quest'ultima e si calcola lo score.

** Day 5
*** Parte 1

    Non sappiamo quanto grande è la mappa e quindi dovremo usare una
    sparse map (cioè una hash table / dizionario): a una coppia di
    coordinate corrisponderà il numero di vortici presenti.

    Creiamo una funzione draw(x0, y0, x1, y1) che aggiunge i vortici
    lungo i punti della linea.

    Il problema dice che le linee sono verticali o orizzontali e
    questo semplifica tutto perché basta incrementare le due variabili
    x0, y0 ad ogni iterazione del loop di una quantità costante (1, 0
    o -1): non succederà mai che una delle due coordinate aumenti più
    di un pixel per iterazione.

    Se le righe fossero state arbitrarie avremmo dovuto ricorrere ad
    algoritmi più complicati (Bresenham lineare).

    Bisogna solo determinare l'incremento ad ogni iterazione.

    Il codice può essere abbozzato come segue:

    #+BEGIN_SRC python
      def draw(x0, y0, x1, y1):
	  sx = x0 < x1 and 1 or (x0 > x1 and -1 or 0)
	  sy = y0 < y1 and 1 or (y0 > y1 and -1 or 0)

	  while True:
		  m[x0, y0] = m.get((x0, y0), 0) + 1
		  if x0 == x1 and y0 == y1:
			  break
		  x0 += sx
		  y0 += sy
    #+END_SRC

    La funzione draw dovrà essere chiamata solo per le righe
    orizzontali e verticali, cioè quelle in cui x0 == x1 oppure
    y0 == y1.

    Dopo aver disegnato ogni segmento sarà sufficiente contare gli
    elementi con valore > 1 iterando per ogni elemento del dizionario.

*** Parte 2

    Uguale alla parte 1 tranne che ora ci sono delle linee diagonali
    ma solo a 45°.

    Questa caratteristica ci garantisce che l'incremento per
    iterazione in entrambe le coordinate sia tra {1, 0, -1} e ci
    permette di riutilizzare la stessa procedura semplificata draw()
    vista sopra.

    Nella prima iterazione del codice controllavo che i segmenti
    fossero effettivamente a 45°: basta controllare che abs(x1-x0) ==
    abs(y1-y0).

    Poi, visto che non esistevano segmenti arbitrari nell'input, ho
    tolto il check.

** Day 6
*** Parte 1

    Il testo suggerisce che i pesci lanterna crescono in modo
    esponenziale e quindi un approccio esplicito non funzionerà.

    Nonostante l'indizio ho tentato inizialmente con un approccio
    esplicito, forse perché non ancora perfettamente sveglio: inutile
    dire che elencare ogni pesce in un array, anche se ordinato,
    sicuramente diventerà un disastro nella parte 2 del problema.

    Invece possiamo contare quanti pesci si riprodurranno in un
    determinato giorno.

    Con l'esempio di partenza 3,4,3,1,2:

    | giorno | numero pesci |
    |      1 |            0 |
    |      2 |            1 |
    |      3 |            1 |
    |      4 |            2 |
    |      5 |            1 |

    Il giorno 1 non c'è alcun pesce che si riproduce, quindi il totale
    dei pesci resta 5, la quantità iniziale.

    Il giorno 2 c'è un pesce che si riproduce quindi il totale dei
    pesci presenti il giorno 2 diventa 6 (5 + 1).

    Il pesce che si è riprodotto e il pesce neonato a loro volta si
    riprodurranno nei giorni futuri:

    | giorno | numero pesci |                                              |
    | 2 + 7  | pesci + 1    | il pesce si riproduce di nuovo               |
    | 2 + 9  | pesci + 1    | il pesce neonato si riproduce la prima volta |

    Perché aggiungiamo 7 e 9 anziché 6 e 8? Perché il testo suggerisce
    che il timer 0 è un valore valido, quindi in realtà trascorrono 7
    giorni e non 6 per la prossima riproduzione anche se il timer
    parte da 6.

    Passando al giorno 3: c'è un pesce che si riproduce quindi il
    totale arriva a 7 (6 + 1). Questo pesce si riprodurrà di nuovo il
    giorno 3 + 7 e il nuovo pesce si riprodurrà per la prima volta il
    giorno 3 + 9. Quindi aggiorniamo l'array della riproduzione dei
    pesci per i giorni 3 + 7 e 3 + 9.

    Passando al giorno 4: ci sono due pesci che si riproducono quindi
    il totale arriva a 9 (7 + 2). Questi due pesci si riprodurranno di
    nuovo nei giorni 4 + 7 e i due pesci neonati nei giorni
    4 + 9. Quindi aggiorniamo l'array della riproduzione dei pesci nei
    giorni 4 + 7 e 4 + 9 (con due pesci stavolta!).

    | giorno | numero pesci |                                             |
    | 4 + 7  | pesci + 2    | i due pesci si riproducono di nuovo         |
    | 4 + 9  | pesci + 2    | i due neonati si riproducono la prima volta |

    E così via fino ad arrivare al giorno 80.

    In pratica dobbiamo solo mantenere un array col numero di pesci
    che si riproducono per ogni giorno che passa, aggiornandolo giorno
    per giorno tenendo conto delle nuove nascite: la soluzione è
    programmazione dinamica.

    L'algoritmo è l'implementazione esatta della descrizione appena
    data con l'unica accortezza che il giorno 1 ha indice array
    pari 0 (quindi contiamo da 0 fino a 79 incluso).

    #+BEGIN_SRC python
      def solve(ages, days):
	  day = [0] * (days + 9)

	  for age in ages:
	      day[age] += 1

	  count = len(ages)
	  for i in range(days):
	      count += day[i]
	      day[i + 7] += day[i]
	      day[i + 9] += day[i]

	  return count
    #+END_SRC

*** Parte 2

    Identica alla parte 1 tranne che si arriva a 256 giorni anziché
    a 80.

    E' qui che si vede la potenza della programmazione dinamica:
    l'approccio esplicito sarebbe stato impossibile e il tempo di
    esecuzione improponibile.

    Invece l'algoritmo produce una soluzione in pochi millisecondi
    anche in python. In C e C++ la soluzione impiega meno di un
    millisecondo. Per evitare overflow ho usato interi unsigned a 64
    bit.

** Day 7
*** Parte 1

    Al di là del significato matematico del risultato che si vuole
    trovare il problema sembra di facile soluzione: per ogni posizione
    possibile calcoliamo il costo necessario a far convergere tutti i
    granchi a tale posizione.

    Il costo è il valore assoluto della differenza tra la posizione
    del granchio e la posizione scelta.

    Tra tutte le posizioni possibili scegliamo quella con costo più
    basso.

    L'implementazione impiega pochissimo anche in python, se c'è
    bisogno di una soluzione non brute-force lo vedremo nella parte 2.

*** Parte 2

    Come la parte 1 solo che cambia il calcolo del costo in carburante
    in funzione della distanza. In particolare, se la distanza è d il
    costo in carburante è la somma dei numeri naturali da 1 a d e
    cioè:

    #+BEGIN_EXAMPLE
    d * (d+1) / 2
    #+END_EXAMPLE

    [[https://it.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%C2%B7_%C2%B7_%C2%B7][Formula di Gauss]].

    Anche qui ci mette poco anche in python, inutile cercare soluzioni
    più elaborate.

    La soluzione C++, che usa le funzioni lambda a tutto spiano,
    impiega un tempo paragonabile alla soluzione C.

** Day 8
*** Parte 1

    La prima parte del problema è di facile soluzione in quanto
    consiste nel contare le parole con 2, 3, 4 e 7 caratteri.

*** Parte 2

    La seconda parte è più complicata perché dobbiamo determinare la
    corripondenza dei segmenti illuminati con le cifre.

    Dalla prima parte del problema sappiamo già associare a
    determinati segmenti determinate cifre:

    1) ai 2 caratteri corrisponde la cifra 1
    2) ai 3 caratteri corrisponde la cifra 7
    3) ai 4 caratteri corrisponde la cifra 4
    4) ai 7 caratteri corrisponde la cifra 8

    Rimane il problema di determinare quali sono gli altri caratteri e
    per farlo dobbiamo analizzare come sono rappresentati.

    Il primo problema da risolvere è la rappresentazione dei segmenti
    illuminati: ad esempio i segmenti "abcdefg" corrispondono a
    "gfedcba" e a tutte le sue permutazioni. Quindi abbiamo bisogno di
    un modo per rappresentare i segmenti che non tenga conto
    dell'ordine in cui appaiono le lettere.

    Per farlo ho usato una semplice bitmap calcolata come segue:

    #+BEGIN_SRC python
      letters = "abcdefg"

      def encode(lseg):
	  nseg = 0
	  for l in lseg:
	      nseg |= 1 << letters.index(l)
	  return nseg
    #+END_SRC

    In questo modo una sequenza di segmenti in lettere produce sempre
    lo stesso numero indipendentemente dal loro ordine. Si può
    ottenere lo stesso risultato ordinando le lettere o usando dei
    set.

    Per risolvere il problema è necessario contare quanti segmenti
    sono accesi. Nella rappresentazione letterale è semplice perché
    basta contare il numero dei caratteri. Per quella numerica bisogna
    contare il numero dei bit. Per farlo si possono usare le seguenti
    funzioni:

    #+BEGIN_SRC python
      def bitcount(i):
	  return bin(i).count("1")
    #+END_SRC

    In C/C++ si può usare l'intrinsic x86 popcnt() oppure la funzione
    di Kernighan:

    #+BEGIN_SRC c
      int bitcount(unsigned x)
      {
	      int count = 0;
	      while (x)
	      {
		      x &= x - 1;
		      count++;
	      }
	      return count;
      }
    #+END_SRC

    Tornando alla soluzione del problema possiamo partire dalla
    rappresentazione delle cifre in segmenti e precalcolare quanti
    segmenti accesi ha ogni cifra:

    | Cifra | Segmenti | Numero segmenti |
    |     0 | abcefg   |               6 |
    |     1 | cf       |               2 |
    |     2 | acdeg    |               5 |
    |     3 | acdfg    |               5 |
    |     4 | bcdf     |               4 |
    |     5 | abdfg    |               5 |
    |     6 | abdefg   |               6 |
    |     7 | acf      |               3 |
    |     8 | abcdefg  |               7 |
    |     9 | abdfg    |               6 |

    In questo modo quando mi imbatterò in una word di lunghezza 5 (ad
    esempio "cdfbe") saprò che ad essa potranno corrispondere le
    seguenti cifre: 2, 3, 5.

    Con una word di lunghezza 6 (ad esempio "cefabd") avremo le
    seguenti cifre possibili: 0, 6, 9.

    Ogni segmento letto viene quindi associato alle cifre potenziali
    che potrebbe rappresentare. Alcune cifre (1, 4, 7, e 8) avranno
    una lista di un solo elemento e sono quelle la cui
    rappresentazione è già determinata.

    Per il primo esempio del problema ottengo il seguente elenco (ho
    ordinato le lettere dei segmenti):

    | Cifra | Segmenti             | Determinata |
    |     0 | abcdef bcdefg abcdeg |             |
    |     1 | ab                   | *           |
    |     2 | bcdef acdfg abcdf    |             |
    |     3 | bcdef acdfg abcdf    |             |
    |     4 | abef                 | *           |
    |     5 | bcdef acdfg abcdf    |             |
    |     6 | abcdef bcdefg abcdeg |             |
    |     7 | abd                  | *           |
    |     8 | abcdefg              | *           |
    |     9 | abcdef bcdefg abcdeg |             |

    Rimane il problema di eliminare i segmenti sbagliati. Per farlo
    bisogna osservare la rappresentazione delle cifre: ad esempio
    osserviamo che la cifra 1, che ha normalmente rappresentazione
    "cf", ha in comune con la cifra 3 entrambi i segmenti (la cifra 3
    ha come normale rappresentazione "acdfg").

    Nel nostro esempio i collegamenti sono stati mescolati ma la
    proprietà deve rimanere, cioè la rappresentazione di 1 è "ab" e
    questi due segmenti devono entrambi essere presenti nella
    rappresentazione di 3.

    Ma se osserviamo i possibili candidati della cifra 3, i primi due
    hanno solo un segmento in comune con la cifra 1! Non possono
    rappresentare la cifra 3, perciò li eliminiamo.

    Risultato: la cifra 3 è associata al segmento "abcdf".

    | Cifra | Segmenti             | Determinata |
    |     0 | abcdef bcdefg abcdeg |             |
    |     1 | ab                   | *           |
    |     2 | bcdef acdfg abcdf    |             |
    |     3 | abcdf                | *           |
    |     4 | abef                 | *           |
    |     5 | bcdef acdfg abcdf    |             |
    |     6 | abcdef bcdefg abcdeg |             |
    |     7 | abd                  | *           |
    |     8 | abcdefg              | *           |
    |     9 | abcdef bcdefg abcdeg |             |

    Per lo stesso ragionamento sulla cifra 1 eliminiamo anche:
    * "bcdefg" dalla cifra 0 (deve avere 2 segmenti in comune)
    * "abcdf" dalla cifra 2 (deve avere 1 segmento in comune)
    * "abcdf" dalla cifra 5 (deve avere 1 segmento in comune)
    * "abcdef" e "abcdeg" dalla cifra 6 (deve avere 1 segmento in comune)
    * "bcdefg" dalla cifra 9 (deve avere due segmenti in comune)

    | Cifra | Segmenti      | Determinata |
    |     0 | abcdef abcdeg |             |
    |     1 | ab            | *           |
    |     2 | bcdef acdfg   |             |
    |     3 | abcdf         | *           |
    |     4 | abef          | *           |
    |     5 | bcdef acdfg   |             |
    |     6 | bcdefg        | *           |
    |     7 | abd           | *           |
    |     8 | abcdefg       | *           |
    |     9 | abcdef abcdeg |             |

    Ora procediamo con la cifra 3 che ha rappresentazione "abcdf", ed
    eliminiamo:
    * "abcdef" dalla cifra 0 (deve avere 4 segmenti comuni)
    * "abcdeg" dalla cifra 9 (deve avere 5 segmenti comuni)

    | Cifra | Segmenti    | Determinata |
    |     0 | abcdeg      | *           |
    |     1 | ab          | *           |
    |     2 | bcdef acdfg |             |
    |     3 | abcdf       | *           |
    |     4 | abef        | *           |
    |     5 | bcdef acdfg |             |
    |     6 | bcdefg      | *           |
    |     7 | abd         | *           |
    |     8 | abcdefg     | *           |
    |     9 | abcdef      | *           |

    Procediamo con la cifra 4 che ha rappresentazione "abef" ed
    eliminiamo:
    * "bcdef" dalla cifra 2 (deve avere 2 segmenti comuni)
    * "acdfg" dalla cifra 5 (deve avere 3 segmenti comuni)

    | Cifra | Segmenti | Determinata |
    |     0 | abcdeg   | *           |
    |     1 | ab       | *           |
    |     2 | acdfg    | *           |
    |     3 | abcdf    | *           |
    |     4 | abef     | *           |
    |     5 | bcdef    | *           |
    |     6 | bcdefg   | *           |
    |     7 | abd      | *           |
    |     8 | abcdefg  | *           |
    |     9 | abcdef   | *           |

    A questo punto abbiamo completato la mappatura da cifra ->
    segmenti e possiamo decifrare i numeri sul display:

    | Segmenti | Ordinati | Cifra |
    | cdfeb    | bcdef    |     5 |
    | fcadb    | abcdf    |     3 |
    | cdfeb    | bcdef    |     5 |
    | cdbaf    | abcdf    |     3 |


    Per eliminare i candidati abbiamo bisogno di una matrice che ci
    dica quanti segmenti in comune esistono tra due cifre arbitarie i
    e j, calcolando il numero degli elementi dell'intersezione dei
    segmenti.

    Questa matrice è di facile costruzione ed è simmetrica:

    #+BEGIN_EXAMPLE
    M[i][j] = bitcount(encode(seg[i]) & encode(seg[j]))
    #+END_EXAMPLE

    A questo punto è facile eliminare i candidati errati: se i è una
    cifra con una rappresentazione predeterminata e j ha più
    candidati, possiamo eliminare il candidato k in cui:

    #+BEGIN_EXAMPLE
    bitcount(seg[i] & seg[j][k]) != M[i][j]
    #+END_EXAMPLE

    Alla fine del procedimento di eliminazione, se il numero di
    candidati arriva a 1, abbiamo determinato la rappresentazione a
    segmenti della cifra.

    NOTA: per la prima soluzione del problema non ho usato questo
    approccio perché mi avrebbe portato via troppo tempo e ho
    preferito un brute-force con permutazioni, trovando la
    permutazione che generasse un elemento per ogni cifra.

    Poi con calma ho sviluppato il modo più ragionato.

** Day 9

*** Parte 1

    Creiamo la funzione risk(x, y) che calcola il rischio per
    l'elemento (x, y) della mappa.

    Controlliamo se ci sono vicini con valore minore e uguale
    all'elemento: in quel caso non è un punto di minimo e il rischio è
    zero.

    Se invece i vicini hanno valore maggiore dell'elemento, l'elemento
    è un punto di minimo con un rischio uguale a 1 + valore-elemento.

    Eseguiamo risk() per ogni elemento della mappa e sommandone i
    risultati otteniamo il rischio totale.

*** Parte 2

    Dobbiamo esplorare la mappa e lo possiamo fare con una Depth-First
    Search. Avremmo potuto usare anche una Breadth-First Search ma
    l'implementazione della DFS è più veloce.

    La funzione dfs(x, y) restituisce:
    * 0 se il valore in (x, y) == 9
    * 0 se (x, y) è già stato visitato da una ricerca precedente
    * n la dimensione del bacino in cui si trova (x,y).

    Per ogni punto della mappa chiamiamo dfs() e controlliamo il
    valore di ritorno: se è diverso da zero abbiamo trovato un nuovo
    bacino, con area pari al valore stesso. Questo valore è aggiunto
    ad un vettore.

    Al termine avremo un vettore con la dimensione di ogni bacino
    della mappa. Lo ordiniamo in ordine decrescente, prendiamo i primi
    3 valori della lista e li moltiplichiamo tra di loro.

** Day 10

*** Parte 1

    Per analizzare una stringa possiamo usare uno stack: se troviamo
    una parentesi aperta aggiungiamo la corrispondente parentesi
    chiusa allo stack, se ne troviamo una chiusa controlliamo l'ultimo
    elemento dello stack e vediamo se le due parentesi sono uguali.

    Se sono uguali rimuoviamo l'ultimo elemento dello stack.

    Se non lo sono segnaliamo l'errore e calcoliamo il numero dei
    punti.

    #+BEGIN_SRC python
      OPENED = "([{<"
      CLOSED = ")]}>"
      POINTS = [3, 57, 1197, 25137]

      def check_line(line):
	  stack = []
	  for c in line:
	      idx = OPENED.find(c)
	      if idx >= 0:
		  stack.append(CLOSED[idx])
	      else:
		  if c != stack.pop():
		      return POINTS[CLOSED.index(c)]
	  return 0
    #+END_SRC

    Se la riga è incompleta la funzione check_line() restituirà un
    punteggio pari a zero. Se invece la riga ha degli errori sarà
    restituito il punteggio corrispondente all'errore.

    La risposta alla parte 1 è la somma dei punti ottenuti dalla
    funzione check_line() per ciascuna riga dell'input.

*** Parte 2

    Dobbiamo completare la stringa, ma la stringa l'abbiamo già
    completata in quanto sono esattamente i caratteri presenti sullo
    stack in ordine inverso!

    Ad esempio per la prima riga:

    | Input                    | Stack    | reversed(Stack) |
    | [({(<(())[]>[[{[]{<()<>> | ])})]]}} | }}]])})}]       |

    Con questi caratteri possiamo calcolare lo *score* richiesto:

    #+BEGIN_SRC python
      score = 0
      for x in reversed(stack):
	  score = score * 5 + CLOSED.index(x) + 1
    #+END_SRC

    La funzione check_line() è modificata per ritornare sia lo stack
    che il punteggio che indica se la stringa è incompleta
    (punteggio 0) o sbagliata (punteggio > 0).

    La versione C fa uso di qualche trucco per evitare di allocare
    memoria.

** Day 11

*** Parte 1

    Ogni elemento della mappa rappresenta un livello di energia che
    dobbiamo aggiornare ad ogni step seguendo una serie di regole:

    1) ogni polpo aumenta il suo livello di 1 ad ogni step;

    2) se un polpo aumenta l'energia sopra a 9 lampeggia e causa
       l'incremento di energia dei polpi che gli stanno attorno. Per
       effetto dell'incremento, a loro volta i polpi vicini potrebbero
       lampeggiare causando l'aumento di energia di altri polpi vicini
       (attenzione però, che un polpo può lampeggiare una volta sola
       per step).

    3) Un polpo che ha già lampeggiato assume livello di energia zero
       al termine dello step.

    Le regole 2 e 3 ci dicono che se un polpo ha lampeggiato non
    dobbiamo più aggiornare il suo livello di energia anche se dei
    polpi vicini lampeggiano: questo perché il polpo può lampeggiare
    una volta sola e al termine dello step deve avere energia zero.

    Quindi dobbiamo tenere traccia di quali polpi hanno già
    lampeggiato.

    Nel codice abbiamo una matrice 10x10 che viene aggiornata ad ogni
    step. Prima di incrementare il valore di energia di un polpo
    controlliamo se ha già lampeggiato verificando che la sua energia
    sia <= 9.

    La funzione che incrementa l'energia di ogni polpo è ricorsiva:

    1) controlla se il polpo ha energia > 9 (ha già lampeggiato)
       e in quel caso lo lascia stare: questo accorgimento è dettato
       dalla regola 2 che ogni polpo può lampeggiare una sola volta in
       uno step.

    2) aumenta l'energia del polpo di 1 e se supera il livello 9 fa
       lampeggiare il polpo: incrementiamo l'energia di ogni polpo
       vicino.

    Dopo aver richiamato la funzione per ogni polpo della mappa alcuni
    avranno energia >9: sono i quelli che hanno lampeggiato durante lo
    step.

    Li contiamo e impostiamo la loro energia a zero (regola 3), così
    che il prossimo step possa aggiornarli correttamente.

    Sommando i polpi che hanno lampeggiato ad ogni step da 1..100
    otteniamo la risposta alla parte 1.

*** Parte 2

    La parte 2 è banale una volta risolta la parte 1: basta continuare
    a effettuare step finché tutti i polpi lampeggiano.

    A quel punto la risposta è il numero di step effettuati per
    raggiungere questo stato.

** Day 12

*** Parte 1

    Dobbiamo contare tutti i percorsi possibili da "start" a "end" e
    per farlo dobbiamo ricorrere al backtracking: proviamo ogni
    percorso e se arriviamo a "end" lo conteggiamo. Se invece
    prendiamo una strada senza uscita torniamo indietro e scegliamo
    un'altra strada.

    Per rappresentare il grafo della mappa possiamo usare un
    dizionario che associa ad una determinata posizione una lista di
    locazioni da essa raggiungibili:

    #+BEGIN_SRC python
      m = {}
      for line in txt.splitlines():
	  src, dst = line.split("-")
	  m[src] = m.get(src, []) + [dst]
	  m[dst] = m.get(dst, []) + [src]
    #+END_SRC

    La funzione backtrack() esegue il lavoro reale e restituisce il
    numero di percorsi validi trovati:

    #+BEGIN_SRC python
      def backtrack(lst, m):
	  cur = lst[-1]
	  if cur == "end":
	      return 1

	  count = 0
	  for i in m.get(cur, []):
	      should_skip = i.upper() != i and i in lst
	      if should_skip:
		  continue

	      lst.append(i)
	      count += backtrack(lst, m)
	      lst.pop()

	  return count
    #+END_SRC

    Alla funzione passiamo lst che è la lista delle posizioni già
    visitate (inizialmente contiene solo "start") e m il grafo della
    mappa.

    La variabile should_skip controlla se dobbiamo evitare di prendere
    una certa strada: il problema infatti ci dice che non possiamo
    visitare due volte una locazione in minuscolo.

    Prima di richiamare ricorsivamente backtrack() aggiungiamo
    l'elemento candidato *i* alla lista.

    Al ritorno da backtrack() tale elemento viene rimosso.

*** Parte 2

    La parte 2 rilassa il vincolo sulle locazioni minuscole: possiamo
    visitare una sola locazione minuscola al massimo due volte.

    Modelliamo questa regola passando alla funzione backtrack la
    variabile *assigned* che assume il valore True se la locazione
    minuscola è già stata visitata due volte, False altrimenti.

    La funzione backtrack() cambia come segue:

    #+BEGIN_SRC python
      def backtrack(lst, assigned, m):
	  cur = lst[-1]
	  if cur == "end":
	      return 1

	  count = 0
	  for i in m.get(cur, []):
	      should_skip = i.upper() != i and i in lst
	      if should_skip and assigned or i == "start":
		  continue

	      lst.append(i)
	      count += backtrack(lst, assigned or should_skip, m)
	      lst.pop()

	  return count
    #+END_SRC

    In questo caso non è sufficiente controllare should_skip ma
    dobbiamo anche verificare che una locazione minuscola sia stata
    visitata due volte: se non lo è stata allora è permesso visitare
    la locazione minuscola corrente di nuovo. A patto che non sia
    "start".

    Se stiamo visitando una locazione minuscola per la seconda volta
    allora la variabile should_skip è True. Perciò quando chiamiamo
    backtrack() assigned diventa: assigned or should_skip.

    In questo modo se assigned era False diventa True ed eventuali
    locazioni minuscole già visitate non possono più essere visitate.

    Se invece assigned era True rimane True e nulla cambia.

    Possiamo calcolare il risultato della parte 1 col nuovo codice
    passando il parametro assigned = True. Passando il parametro
    assigned = False otterremo invece il risultato della parte 2.

    La versione C implementa uno sparse graph e impiega un tempo di un
    ordine di grandezza inferiore della versione python che soffre
    dell'estrema lentezza del linguaggio nell'eseguire le chiamate
    alle funzioni.

** Day 13

*** Part1

    Abbiamo un foglio con una lista di punti e delle istruzioni da
    seguire per piegarlo: ad ogni piega la lista dei punti viene
    modificata.

    Se pieghiamo verso l'alto (fold up) tutti i punti con coordinata y
    maggiore della linea di piegatura fy devono essere spostati ad una
    nuova coordinata y calcolata come segue:

    #+BEGIN_EXAMPLE
    y' = fy - (y - fy) = fy + fy - y = 2 * fy - y
    #+END_EXAMPLE

    Se pieghiamo verso sinistra (fold left) tutti i punti con
    coordinata x maggiore della linea di piegatura fx devono essere
    spostati ad una nuova coordinata x calcolata come segue:

    #+BEGIN_EXAMPLE
    x' = fx - (x - fx) = fx + fx - x = 2 * fx - x
    #+END_EXAMPLE

    La nuova lista avrà dei punti che si sovrappongono, cioè che
    compaiono più volte.

    Per contare gli elementi distinti possiamo inserirli in un set e
    determinare la dimensione di quest'ultimo.

    Nella versione C e C++ ordiniamo la lista e saltiamo gli elementi
    già contati.

*** Parte 2

    Consiste nell'effettuare tutte le piegature indicate nel testo del
    problema e stampare infine il risultato.

    Per stampare il risultato ordiniamo la lista dei punti dall'alto
    al basso e da sinistra a destra.

    Per ogni punto spostiamo il cursore dalla posizione corrente alla
    posizione del punto e lo stampiamo.

** Day 14

*** Parte 1

    Partiamo dal presupposto che non possiamo creare il polimero
    esplicitamente perché "grows quickly", cioè la crescita è
    sicuramente esponenziale.

    Dopotutto il problema da risolvere consiste nel conteggiare il
    numero delle lettere e non nel riprodurre il polimero.

    Per contare le lettere possiamo usare un dizionario che
    inizialmente contiene solo le lettere del polimero di partenza:

    #+BEGIN_SRC python
      letters = {}
      for x in polymer:
	  letters[x] = letters.get(x, 0) + 1
    #+END_SRC

    Ad esempio per il polimero NNBC è il dizionario è il seguente:

    #+BEGIN_EXAMPLE
    letters = { 'N': 2, 'B': 1, 'C': 1 }
    #+END_EXAMPLE

    Ad ogni applicazione di una nuova regola dovremo aggiornare il
    dizionario aggiungendo la nuova lettera (ad esempio se applichiamo
    la regola 'NN -> C' dovremo aggiungere una nuova lettera C).

    Il dato di partenza per la produzione delle nuove lettere non è il
    polimero completo ma le coppie di lettere che lo
    compongono.

    Anziché memorizzarle sequenzialmente possiamo usare un dizionario:
    se una coppia di lettere NN si ripete *n* volte, il dizionario
    avrà un'entry { 'NN': *n*, ... }.

    Il dizionario iniziale è popolato analizzando il polimero di partenza.

    Ad esempio, per il polimero NNCB che è composto dalle coppie 'NN',
    'NC' e 'NB':

    #+BEGIN_EXAMPLE
    couples = { 'NN': 1, 'NC': 1, 'CB': 1 }
    #+END_EXAMPLE

    Ad ogni step eseguito creeremo un nuovo dizionario usando il
    dizionario iniziale e le regole di inserimento.

    Infatti per ogni coppia di lettere nel dizionario troveremo la
    regola corrispondente e genereremo due nuove coppie, il cui numero
    si somma alle coppie già presenti nel dizionario.

    Ad esempio, se incontriamo nel dizionario la coppia 'NN': 10,
    applichiamo la regola 'NN -> C', producendo le coppie 'NC' e 'CN';
    aggiorneremo quindi il nuovo dizionario aggiungendo 10 alle coppie
    'NC' e 'CN'.

    Contemporaneamente aggiorniamo anche il dizionario delle lettere
    perché applicando la regola 'NN -> C' abbiamo inserito nel
    polimero una nuova lettera C per ciascuna delle coppie 'NN'
    presenti nel dizionario (e cioè 10).

    Effettuiamo questa operazione per ogni coppia del dizionario
    iniziale, completando lo step.

    Lo step dal dizionario visto in precedenza a quello successivo è
    il seguente:
    1) per la coppia 'NN': 1 applichiamo la regola 'NN -> C':
       1. new_couples = {'NC': 1, 'CN': 1}.
       2. letters = {'N': 2, 'B': 1, 'C': 2}.
    2) per la coppia 'NC': 1 applichiamo la regola 'NC -> B':
       1. new_couples = {'NC': 1, 'CN': 1, 'NB': 1, 'BC': 1}
       2. letters = {'N': 2, 'B': 2, 'C': 2}
    3) per la coppia 'CB': 1 applichiamo la regola 'CB -> H':
       1. new_couples = {'NC': 1, 'CN': 1, 'NB': 1, 'BC': 1, 'CH': 1,
          'HB': 1}.
       2. letters = {'N': 2, 'B': 2, 'C': 2, 'H': 1}

    Eseguiti tutti 10 gli step previsti determiniamo la lettera che si
    ripete di più e quella che si ripete di meno (massimo e minimo dei
    valori del dizionario).

    Il risultato è la differenza di questi due valori.

*** Parte 2

    Avendo implementato l'algoritmo in modo efficiente la parte 2 è
    identica alla parte 1, tranne che i passaggi sono 40.

** Day 15

*** Parte 1

    Il problema consiste nella ricerca del percorso più breve da (0,0)
    a (m-1, n-1) considerando come distanza la somma dei rischi nel
    percorso.

    Possiamo usare l'algoritmo di Dijkstra dove ogni arco ha distanza
    pari al rischio del nodo che raggiunge.

*** Parte 2

    Uguale alla parte 1 tranne che dobbiamo estendere la mappa prima
    di fare la ricerca.

    La nuova mappa avrà dimensione n*width x n*height e per ogni sua
    coordinata (x, y) calcoliamo:

    #+BEGIN_EXAMPLE
    rx = x % old_width
    ry = y % old_height
    qx = x // old_width
    qy = y // old_height
    #+END_EXAMPLE

    La funzione che genera il rischio di un punto arbitrario (x, y)
    della nuova mappa sarà:

    #+BEGIN_EXAMPLE
    new[y][x] = (old[ry][rx] + qx + qy - 1) % 9 + 1
    #+END_EXAMPLE

** Day 16

*** Parte 1

    Per risolvere il problema è necessario leggere una quantità
    variabile di bit a partire da una rappresentazione esadecimale di
    lunghezza arbitraria.

    La classe Bitstream agevola il compito consumando la stringa
    esadecimale di partenza e fornendo i bit richiesti di volta in
    volta:

    #+BEGIN_SRC python
      HEXDIGITS = "0123456789ABCDEF"

      class Bitstream(object):
	  def __init__(self, hexstr):
	      self.hexstr = hexstr
	      self.hexpos = 0
	      self.rawdata = 0
	      self.avail = 0
	      self.pos = 0

	  def get(self, bits):
	      while self.avail < bits:
		  if self.hexpos >= len(self.hexstr):
		      raise RuntimeError("EOF")

		  hexval = HEXDIGITS.find(self.hexstr[self.hexpos])
		  if hexval < 0:
		      continue

		  self.rawdata = self.rawdata << 4 | hexval
		  self.hexpos += 1
		  self.avail += 4

	      self.avail -= bits
	      self.pos += bits

	      value = self.rawdata >> self.avail
	      self.rawdata &= (1<<self.avail) - 1
	      return value
    #+END_SRC

    La funzione parse() è invece ricorsiva e usando la bitstream
    effettua il parsing dei pacchetti, restituendo una
    rappresentazione ad albero dei dati.

    Ci sono tre casi:

    1) type == 4: in questo caso il pacchetto contiene un valore
       numerico da decodificare secondo le regole indicate.

    2) type != 4 e bit successivo == 1: gli 11 bit che seguono
       indicano il numero di pacchetti contenuti in quello attuale.

    3) type != 4 e bit successivo == 0: i 15 bit che seguono indicano
       la lunghezza totale dei pacchetti contenuti.

    La risposta alla domanda posta dal problema si ottiene eseguendo
    la funzione interp1() che restituisce la somma delle versioni di
    tutti i pacchetti.

    Dovendo percorrere un albero, la funzione è ricorsiva e richiama
    sè stessa quando il tipo del pacchetto è diverso da 4.

    #+BEGIN_SRC python
      def interp1(tree):
	  ver, typ, children = tree
	  if typ == 4:
	      return ver
	  else:
	      return ver + sum(interp1(x) for x in children)
    #+END_SRC

*** Parte 2

    La soluzione è il valore calcolato dalla funzione interp2() che
    esamina il tipo di pacchetto e a seconda del suo valore esegue
    delle operazioni sui pacchetti figli.

    Anche questa funzione è ricorsiva, dovendo percorrere una
    struttura ad albero.

    Per divertimento c'è anche la funzione tolisp() che converte
    il programma in un'espressione Lisp / Scheme.

** Day 17

*** Parte 1

    Ci si chiede quanto in alto può arrivare la sonda prima di entrare
    nell'area obbiettivo, definita come

    #+BEGIN_EXAMPLE
    target area: x=X0..X1, y=Y0..Y1
    #+END_EXAMPLE

    Teoricamente la possiamo lanciare con una velocità iniziale
    infinitamente alta, ma quando la sonda tornerà indietro mancherà
    l'area obbiettivo perché la coordinata y diminuirà di una quantità
    maggiore alla zona in cui si trova l'area.

    Se osserviamo l'andamento sull'asse Y vediamo infatti che se
    lanciamo la sonda con velocità VY >= 0, dopo un certo numero di
    passaggi (pari esattamente a 2 * VY + 1) la sonda tornerà a y
    = 0.

    A quel punto la velocità VY' = -VY -1 (per effetto della gravità).

    Perciò se -VY - 1 < Y0 la sonda mancherà l'area, mentre se -VY -1
    == Y0 la sonda colpirà l'area nel punto più basso.

    Abbiamo quindi definito il limite superiore della velocità
    iniziale:

    #+BEGIN_EXAMPLE
    VY = -Y0 - 1.
    #+END_EXAMPLE

    Se lanciamo la sonda alla velocità VY raggiungerà il punto più
    alto quando la velocità diventa 0. Quindi la coordinata finale
    y-max sarà uguale alla somma di VY + (VY-1) + (VY-2) + ... + 2 +
    1 + 0.

    Ma questa somma si calcola con la formula di Gauss! Effettuando le
    opportune sostituzioni otteniamo la risposta alla prima domanda:

    #+BEGIN_EXAMPLE
    Y-Max = (Y0+1) * Y0 // 2
    #+END_EXAMPLE

*** Parte 2

    Nella parte 1 abbiamo determinato il valore massimo di VY.

    Possiamo calcolare anche il valore massimo di VX che è banale ed è
    pari a X1: se lanciamo la sonda a velocità X1, alla prima
    iterazione la coordinata x sarà all'interno dell'area.

    Se determiniamo anche i valori minimi di VX e VY potremo simulare
    ogni lancio con velocità comprese tra i minimi e i massimi e
    verificare quante volte la sonda raggiunge l'area target.

    Il valore minimo di VY è banale ed è pari a Y0: se lanciamo la
    sonda a una velocità Y0 alla prima iterazione la coordinata y sarà
    all'interno dell'area target.

    Resta da determinare il valore minimo di VX: osserviamo infatti
    che se VX è troppo bassa la sonda non arriverà mai all'area
    target: la distanza percorsa lungo l'asse X dalla sonda è pari a:

    #+BEGIN_EXAMPLE
    d = (VX + 1) * VX // 2
    #+END_EXAMPLE

    Sapendo la distanza minima in X che dobbiamo percorrere, e cioè
    X0, dobbiamo calcolare *VX* tale per cui d = X0.

    Dobbiamo trovare cioè la radice positiva dell'equazione:

    #+BEGIN_EXAMPLE
    vx^2 + vx - 2*X0 = 0
    #+END_EXAMPLE

    La soluzione è (sqrt(1 + 8 * X0) - 1) / 2, ma noi abbiamo bisogno
    dell'intero più vicino per eccesso, quindi applichiamo la funzione
    ceil().

    Avendo un'intervallo in VX e uno in VY possiamo ora simulare i
    lanci per ogni VX e VY e contare quante volte la sonda cade
    nell'area target.

    Possiamo ottimizzare la simulazione evitando di calcolare le
    velocità VY >= 0.

    Infatti dall'osservazione nella Parte 1, dopo 2*VY+1 passaggi y =
    0 e VY' = -VY - 1.

    Per la coordinata x ci sono due casi:
    1) 2*VY+1 >= X: in questo caso VX' = 0 e x = (VX+1) * VX // 2.
    2) 2*VY+1 < X: la velocità residua VX' = VX - (2*VY+1) mentre la
       posizione in x = (VX+1) * VX // 2 - (2*VY+2) * (2*VY+1) // 2.
