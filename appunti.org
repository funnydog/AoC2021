* Advent Of Code 2021

  I think it's time to blow this thing

  Get everybody and their stuff together

  Okay 3-2-1

  Let's jam... (cit)

** Day 1

*** Parte 1
    Prima parte molto semplice:
    1) il primo elemento viene assegnato alla variabile prev (previous,
       precedente).
    2) iteriamo dal secondo elemento all'ultimo confrontandolo con il
       prev e incrementando count se necessario.
    3) alla fine di ogni iterazione assegniamo a prev il valore
       corrente.

    Lo pseudo codice è il seguente:

    #+BEGIN_SRC python
    count = 0
    prev = depths[0]
      for cur in depths[1:]:
	 if prev < cur:
		 count += 1
	 prev = cur
    print(count)
    #+END_SRC

*** Parte 2
    Seconda parte abbastanza semplice, osservando che si tratta dello
    stesso algoritmo precedente ma applicato alla somma di tre elementi
    consecutivi.

    Possiamo calcolare la somma dei tre elementi con due loop annidati.

    Oppure possiamo calcolare solo la prima somma e aggiustarla con
    un'addizione e una sottrazione per ogni elemento successivo:

    #+BEGIN_EXAMPLE
    sum(i+1) = sum(i) - elemento(i + 3) - elemento(i)
    #+END_EXAMPLE

    Per un totale di n-2 somme.

    Ad un esame più approfondito noto che lo stesso ragionamento si
    può applicare per risolvere la parte 1, se la somma iniziale è di
    un solo elemento.

    Quindi possiamo usare lo stesso identico codice per entrambi i
    casi.

** Day2


*** Parte 1
    La prima parte è semplice, si tratta di interpretare correttamente
    tre istruzioni.

    La difficoltà maggiore è nel parsing dei dati: in python leggiamo
    il file intero con f.read()

    Applicando alla stringa ottenuta .splitlines() lo suddividiamo in
    linee.

    Dividiamo ogni stringa in due stringhe separate delimitate da spazi
    con .split().

    La prima stringa resta com'è, la seconda viene convertita in un
    numero intero. Codice Python:

    #+BEGIN_SRC python
    [(x[0], int(x[1])) for x in (x.split() for x in f.read().splitlines())]
    #+END_SRC

*** Parte 2
    La seconda parte è una variazione della prima con la modifica
    semantica delle istruzioni. Senza astrarre inutilmente il codice
    creo una funzione di interpretazione delle istruzioni diversa per
    ciascuna parte da risolvere.

** Day 3

   Problema abbastanza noioso, sarà per via del wall-of-text?
   Insomma.

   Questi problemi dell'AoC che sembrano completamente artificiali
   sono risolti di solito da qualche algoritmo famoso che in questo
   caso mi sfugge.

   Avendo a che fare con il conteggio dei bit forse è collegato a
   qualche sistema di error-correction.

   Lo risolvo solo in python per il momento.

** Day 4
*** Parte 1

    Abbiamo una lista di numeri e delle schede del bingo da caricare
    in memoria e dobbiamo anche tenere traccia di quali numeri della
    scheda sono stati estratti.

    Il problema principale è determinare la struttura dati più adatta
    per rappresentare le schede e per risolvere il problema.

    Per la lista dei numeri la struttura è semplicemente un array.

    Per le schede proviamo ad usare due array:
    1) un array con 25 numeri per rappresentare i numeri sulla scheda.
    2) un array con 25 bool per segnare se il numero alla posizione
       corrispondente è stato estratto.

    Per mappare la posizione (x, y) => pos usiamo la formula:

    #+BEGIN_EXAMPLE
    pos = y * 5 + x
    #+END_EXAMPLE

    Viceversa per pos => (x, y):

    #+BEGIN_EXAMPLE
    x = pos % 5
    y = pos // 5
    #+END_EXAMPLE

    Ogni scheda inoltre ha un campo won che segnala se è già vincente:
    in questo caso anche se marchiamo un numero non è necessario
    ricalcolare se la scheda ha vinto.

    Una funzione mark(board, n) cerca nella scheda il numero n e se lo
    trova lo segna come estratto.

    Possiamo creare un'altra funzione check(board) per vedere se la
    scheda è vincente. Così facendo però dovremmo visitare tutte le
    colonne e tutte le righe.

    Invece possiamo effettuare il check solo sull'ultimo numero che è
    stato estratto, controllando la riga e la colonna cui appartiene.

    E' meglio quindi fondere mark() e check() in un'unica funzione
    mark_and_check() che:
    1) controlla se il numero è presente nella scheda e lo segna
       estratto.
    2) controlla se la riga del numero estratto è stata tutta estratta
    3) controlla se la colonna del numero estratto è stata tutta
       estratta
    4) restituisce un bool che indica se la scheda è vincente.

    In particolare il seguente codice python:

    #+BEGIN_SRC python
      self.won = self.won \
	  or self.check_row(pos) \
	  or self.check_column(pos)
    #+END_SRC

    sfrutta il cosiddetto short-circuiting dell'operatore *or*: se la
    prima condizione (self.won) è già *True* non elabora le condizioni
    successive.

    Per il calcolo dei punti (score) la struttura dei dati scelta
    risulta adatta: basta iterare per ogni numero della scheda,
    controllare se non è stato marcato e quindi sommarlo.

*** Parte 2

    Basta semplicemente eliminare dalla lista delle schede ogni scheda
    vincente finché non ne resta una sola. A questo punto si arriva al
    numero che fa vincere quest'ultima e si calcola lo score.

** Day 5
*** Parte 1

    Non sappiamo quanto grande è la mappa e quindi dovremo usare una
    sparse map (cioè una hash table / dizionario): a una coppia di
    coordinate corrisponderà il numero di vortici presenti.

    Creiamo una funzione draw(x0, y0, x1, y1) che aggiunge i vortici
    lungo i punti della linea.

    Il problema dice che le linee sono verticali o orizzontali e
    questo semplifica tutto perché basta incrementare le due variabili
    x0, y0 ad ogni iterazione del loop di una quantità costante (1, 0
    o -1): non succederà mai che una delle due coordinate aumenti più
    di un pixel per iterazione.

    Se le righe fossero state arbitrarie avremmo dovuto ricorrere ad
    algoritmi più complicati (Bresenham lineare).

    Bisogna solo determinare l'incremento ad ogni iterazione.

    Il codice può essere abbozzato come segue:

    #+BEGIN_SRC python
      def draw(x0, y0, x1, y1):
	  sx = x0 < x1 and 1 or (x0 > x1 and -1 or 0)
	  sy = y0 < y1 and 1 or (y0 > y1 and -1 or 0)

	  while True:
		  m[x0, y0] = m.get((x0, y0), 0) + 1
		  if x0 == x1 and y0 == y1:
			  break
		  x0 += sx
		  y0 += sy
    #+END_SRC

    La funzione draw dovrà essere chiamata solo per le righe
    orizzontali e verticali, cioè quelle in cui x0 == x1 oppure
    y0 == y1.

    Dopo aver disegnato ogni segmento sarà sufficiente contare gli
    elementi con valore > 1 iterando per ogni elemento del dizionario.

*** Parte 2

    Uguale alla parte 1 tranne che ora ci sono delle linee diagonali
    ma solo a 45°.

    Questa caratteristica ci garantisce che l'incremento per
    iterazione in entrambe le coordinate sia tra {1, 0, -1} e ci
    permette di riutilizzare la stessa procedura semplificata draw()
    vista sopra.

    Nella prima iterazione del codice controllavo che i segmenti
    fossero effettivamente a 45°: basta controllare che abs(x1-x0) ==
    abs(y1-y0).

    Poi, visto che non esistevano segmenti arbitrari nell'input, ho
    tolto il check.

** Day 6
*** Parte 1

    Il testo suggerisce che i pesci lanterna crescono in modo
    esponenziale e quindi un approccio esplicito non funzionerà.

    Nonostante l'indizio ho tentato inizialmente con un approccio
    esplicito, forse perché non ancora perfettamente sveglio: inutile
    dire che elencare ogni pesce in un array, anche se ordinato,
    sicuramente diventerà un disastro nella parte 2 del problema.

    Invece possiamo contare quanti pesci si riprodurranno in un
    determinato giorno.

    Con l'esempio di partenza 3,4,3,1,2:

    | giorno | numero pesci |
    |      1 |            0 |
    |      2 |            1 |
    |      3 |            1 |
    |      4 |            2 |
    |      5 |            1 |

    Il giorno 1 non c'è alcun pesce che si riproduce, quindi il totale
    dei pesci resta 5, la quantità iniziale.

    Il giorno 2 c'è un pesce che si riproduce quindi il totale dei
    pesci presenti il giorno 2 diventa 6 (5 + 1).

    Il pesce che si è riprodotto e il pesce neonato a loro volta si
    riprodurranno nei giorni futuri:

    | giorno | numero pesci |                                              |
    | 2 + 7  | pesci + 1    | il pesce si riproduce di nuovo               |
    | 2 + 9  | pesci + 1    | il pesce neonato si riproduce la prima volta |

    Perché aggiungiamo 7 e 9 anziché 6 e 8? Perché il testo suggerisce
    che il timer 0 è un valore valido, quindi in realtà trascorrono 7
    giorni e non 6 per la prossima riproduzione anche se il timer
    parte da 6.

    Passando al giorno 3: c'è un pesce che si riproduce quindi il
    totale arriva a 7 (6 + 1). Questo pesce si riprodurrà di nuovo il
    giorno 3 + 7 e il nuovo pesce si riprodurrà per la prima volta il
    giorno 3 + 9. Quindi aggiorniamo l'array della riproduzione dei
    pesci per i giorni 3 + 7 e 3 + 9.

    Passando al giorno 4: ci sono due pesci che si riproducono quindi
    il totale arriva a 9 (7 + 2). Questi due pesci si riprodurranno di
    nuovo nei giorni 4 + 7 e i due pesci neonati nei giorni
    4 + 9. Quindi aggiorniamo l'array della riproduzione dei pesci nei
    giorni 4 + 7 e 4 + 9 (con due pesci stavolta!).

    | giorno | numero pesci |                                             |
    | 4 + 7  | pesci + 2    | i due pesci si riproducono di nuovo         |
    | 4 + 9  | pesci + 2    | i due neonati si riproducono la prima volta |

    E così via fino ad arrivare al giorno 80.

    In pratica dobbiamo solo mantenere un array col numero di pesci
    che si riproducono per ogni giorno che passa, aggiornandolo giorno
    per giorno tenendo conto delle nuove nascite: la soluzione è
    programmazione dinamica.

    L'algoritmo è l'implementazione esatta della descrizione appena
    data con l'unica accortezza che il giorno 1 ha indice array
    pari 0 (quindi contiamo da 0 fino a 79 incluso).

    #+BEGIN_SRC python
      def solve(ages, days):
	  day = [0] * (days + 9)

	  for age in ages:
	      day[age] += 1

	  count = len(ages)
	  for i in range(days):
	      count += day[i]
	      day[i + 7] += day[i]
	      day[i + 9] += day[i]

	  return count
    #+END_SRC

*** Parte 2

    Identica alla parte 1 tranne che si arriva a 256 giorni anziché
    a 80.

    E' qui che si vede la potenza della programmazione dinamica:
    l'approccio esplicito sarebbe stato impossibile e il tempo di
    esecuzione improponibile.

    Invece l'algoritmo produce una soluzione in pochi millisecondi
    anche in python. In C e C++ la soluzione impiega meno di un
    millisecondo. Per evitare overflow ho usato interi unsigned a 64
    bit.

** Day 7
*** Parte 1

    Al di là del significato matematico del risultato che si vuole
    trovare il problema sembra di facile soluzione: per ogni posizione
    possibile calcoliamo il costo necessario a far convergere tutti i
    granchi a tale posizione.

    Il costo è il valore assoluto della differenza tra la posizione
    del granchio e la posizione scelta.

    Tra tutte le posizioni possibili scegliamo quella con costo più
    basso.

    L'implementazione impiega pochissimo anche in python, se c'è
    bisogno di una soluzione non brute-force lo vedremo nella parte 2.

*** Parte 2

    Come la parte 1 solo che cambia il calcolo del costo in carburante
    in funzione della distanza. In particolare, se la distanza è d il
    costo in carburante è la somma dei numeri naturali da 1 a d e
    cioè:

    #+BEGIN_EXAMPLE
    d * (d+1) / 2
    #+END_EXAMPLE

    [[https://it.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%C2%B7_%C2%B7_%C2%B7][Formula di Gauss]].

    Anche qui ci mette poco anche in python, inutile cercare soluzioni
    più elaborate.

    La soluzione C++, che usa le funzioni lambda a tutto spiano,
    impiega un tempo paragonabile alla soluzione C.
