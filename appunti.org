* Advent Of Code 2021

  I think it's time to blow this thing

  Get everybody and their stuff together

  Okay 3-2-1

  Let's jam... (cit)

** Day 1

*** Parte 1
    Prima parte molto semplice:
    1) il primo elemento viene assegnato alla variabile prev (previous,
       precedente).
    2) iteriamo dal secondo elemento all'ultimo confrontandolo con il
       prev e incrementando count se necessario.
    3) alla fine di ogni iterazione assegniamo a prev il valore
       corrente.

    Lo pseudo codice è il seguente:

    #+BEGIN_SRC python
    count = 0
    prev = depths[0]
      for cur in depths[1:]:
	 if prev < cur:
		 count += 1
	 prev = cur
    print(count)
    #+END_SRC

*** Parte 2
    Seconda parte abbastanza semplice, osservando che si tratta dello
    stesso algoritmo precedente ma applicato alla somma di tre elementi
    consecutivi.

    Possiamo calcolare la somma dei tre elementi con due loop annidati.

    Oppure possiamo calcolare solo la prima somma e aggiustarla con
    un'addizione e una sottrazione per ogni elemento successivo:

    #+BEGIN_EXAMPLE
    sum(i+1) = sum(i) - elemento(i + 3) - elemento(i)
    #+END_EXAMPLE

    Per un totale di n-2 somme.

    Ad un esame più approfondito noto che lo stesso ragionamento si
    può applicare per risolvere la parte 1, se la somma iniziale è di
    un solo elemento.

    Quindi possiamo usare lo stesso identico codice per entrambi i
    casi.

** Day2


*** Parte 1
    La prima parte è semplice, si tratta di interpretare correttamente
    tre istruzioni.

    La difficoltà maggiore è nel parsing dei dati: in python leggiamo
    il file intero con f.read()

    Applicando alla stringa ottenuta .splitlines() lo suddividiamo in
    linee.

    Dividiamo ogni stringa in due stringhe separate delimitate da spazi
    con .split().

    La prima stringa resta com'è, la seconda viene convertita in un
    numero intero. Codice Python:

    #+BEGIN_SRC python
    [(x[0], int(x[1])) for x in (x.split() for x in f.read().splitlines())]
    #+END_SRC

*** Parte 2
    La seconda parte è una variazione della prima con la modifica
    semantica delle istruzioni. Senza astrarre inutilmente il codice
    creo una funzione di interpretazione delle istruzioni diversa per
    ciascuna parte da risolvere.

** Day 3

   Problema abbastanza noioso, sarà per via del wall-of-text?
   Insomma.

   Questi problemi dell'AoC che sembrano completamente artificiali
   sono risolti di solito da qualche algoritmo famoso che in questo
   caso mi sfugge.

   Avendo a che fare con il conteggio dei bit forse è collegato a
   qualche sistema di error-correction.

   Lo risolvo solo in python per il momento.

** Day 4
*** Parte 1

    Abbiamo una lista di numeri e delle schede del bingo da caricare
    in memoria e dobbiamo anche tenere traccia di quali numeri della
    scheda sono stati estratti.

    Il problema principale è determinare la struttura dati più adatta
    per rappresentare le schede e per risolvere il problema.

    Per la lista dei numeri la struttura è semplicemente un array.

    Per le schede proviamo ad usare due array:
    1) un array con 25 numeri per rappresentare i numeri sulla scheda.
    2) un array con 25 bool per segnare se il numero alla posizione
       corrispondente è stato estratto.

    Per mappare la posizione (x, y) => pos usiamo la formula:

    #+BEGIN_EXAMPLE
    pos = y * 5 + x
    #+END_EXAMPLE

    Viceversa per pos => (x, y):

    #+BEGIN_EXAMPLE
    x = pos % 5
    y = pos // 5
    #+END_EXAMPLE

    Ogni scheda inoltre ha un campo won che segnala se è già vincente:
    in questo caso anche se marchiamo un numero non è necessario
    ricalcolare se la scheda ha vinto.

    Una funzione mark(board, n) cerca nella scheda il numero n e se lo
    trova lo segna come estratto.

    Possiamo creare un'altra funzione check(board) per vedere se la
    scheda è vincente. Così facendo però dovremmo visitare tutte le
    colonne e tutte le righe.

    Invece possiamo effettuare il check solo sull'ultimo numero che è
    stato estratto, controllando la riga e la colonna cui appartiene.

    E' meglio quindi fondere mark() e check() in un'unica funzione
    mark_and_check() che:
    1) controlla se il numero è presente nella scheda e lo segna
       estratto.
    2) controlla se la riga del numero estratto è stata tutta estratta
    3) controlla se la colonna del numero estratto è stata tutta
       estratta
    4) restituisce un bool che indica se la scheda è vincente.

    In particolare il seguente codice python:

    #+BEGIN_SRC python
      self.won = self.won \
	  or self.check_row(pos) \
	  or self.check_column(pos)
    #+END_SRC

    sfrutta il cosiddetto short-circuiting dell'operatore *or*: se la
    prima condizione (self.won) è già *True* non elabora le condizioni
    successive.

    Per il calcolo dei punti (score) la struttura dei dati scelta
    risulta adatta: basta iterare per ogni numero della scheda,
    controllare se non è stato marcato e quindi sommarlo.

*** Parte 2

    Basta semplicemente eliminare dalla lista delle schede ogni scheda
    vincente finché non ne resta una sola. A questo punto si arriva al
    numero che fa vincere quest'ultima e si calcola lo score.

** Day 5
*** Parte 1

    Non sappiamo quanto grande è la mappa e quindi dovremo usare una
    sparse map (cioè una hash table / dizionario): a una coppia di
    coordinate corrisponderà il numero di vortici presenti.

    Creiamo una funzione draw(x0, y0, x1, y1) che aggiunge i vortici
    lungo i punti della linea.

    Il problema dice che le linee sono verticali o orizzontali e
    questo semplifica tutto perché basta semplicmente incrementare le
    due variabili x, y ad ogni iterazione del loop.

    Se le righe fossero state arbitrarie avremmo dovuto ricorrere ad
    algoritmi più complicati (Bresenham lineare).

    Bisogna solo determinare l'incremento ad ogni iterazione.

    Il codice può essere abbozzato come segue:

    #+BEGIN_SRC python
      def draw(x0, y0, x1, y1):
	  sx = x0 < x1 and 1 or (x0 > x1 and -1 or 0)
	  sy = y0 < y1 and 1 or (y0 > y1 and -1 or 0)

	  while True:
		  m[x0, y0] = m.get((x0, y0), 0) + 1
		  if x0 == x1 and y0 == y1:
			  break
		  x0 += sx
		  y0 += sy
    #+END_SRC

    La funzione draw dovrà essere chiamata solo per le righe
    orizzontali e verticali, cioè quelle in cui x0 == x1 oppure
    y0 == y1.

    Dopo aver disegnato ogni segmento sarà sufficiente contare gli
    elementi con valore > 1 iterando per ogni elemento del dizionario.

*** Parte 2

    Uguale alla parte 1 tranne che ora ci sono delle linee diagonali
    ma solo a 45°.

    Grazie a questo requisito possiamo usare la stessa procedura
    semplificata draw() vista sopra senza ricorrere all'algoritmo di
    Bresenham.

    Nella prima iterazione del codice controllavo che i segmenti
    fossero effettivamente a 45°: basta controllare che abs(x1-x0) ==
    abs(y1-y0).

    Poi, visto che non esistevano segmenti arbitrari nell'input, ho
    tolto il check.
