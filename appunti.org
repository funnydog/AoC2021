* Advent Of Code 2021

  I think it's time to blow this thing

  Get everybody and their stuff together

  Okay 3-2-1

  Let's jam... (cit)

** Day 1

*** Parte 1
    Prima parte molto semplice:
    1) il primo elemento viene assegnato alla variabile prev (previous,
       precedente).
    2) iteriamo dal secondo elemento all'ultimo confrontandolo con il
       prev e incrementando count se necessario.
    3) alla fine di ogni iterazione assegniamo a prev il valore
       corrente.

    Lo pseudo codice è il seguente:

    #+BEGIN_SRC python
    count = 0
    prev = depths[0]
      for cur in depths[1:]:
	 if prev < cur:
		 count += 1
	 prev = cur
    print(count)
    #+END_SRC

*** Parte 2
    Seconda parte abbastanza semplice, osservando che si tratta dello
    stesso algoritmo precedente ma applicato alla somma di tre elementi
    consecutivi.

    Possiamo calcolare la somma dei tre elementi con due loop annidati.

    Oppure possiamo calcolare solo la prima somma e aggiustarla con
    un'addizione e una sottrazione per ogni elemento successivo:

    #+BEGIN_EXAMPLE
    sum(i+1) = sum(i) - elemento(i + 3) - elemento(i)
    #+END_EXAMPLE

    Per un totale di n-2 somme.

    Ad un esame più approfondito noto che lo stesso ragionamento si
    può applicare per risolvere la parte 1, se la somma iniziale è di
    un solo elemento.

    Quindi possiamo usare lo stesso identico codice per entrambi i
    casi.

** Day2


*** Parte 1
    La prima parte è semplice, si tratta di interpretare correttamente
    tre istruzioni.

    La difficoltà maggiore è nel parsing dei dati: in python leggiamo
    il file intero con f.read()

    Applicando alla stringa ottenuta .splitlines() lo suddividiamo in
    linee.

    Dividiamo ogni stringa in due stringhe separate delimitate da spazi
    con .split().

    La prima stringa resta com'è, la seconda viene convertita in un
    numero intero. Codice Python:

    #+BEGIN_SRC python
    [(x[0], int(x[1])) for x in (x.split() for x in f.read().splitlines())]
    #+END_SRC

*** Parte 2
    La seconda parte è una variazione della prima con la modifica
    semantica delle istruzioni. Senza astrarre inutilmente il codice
    creo una funzione di interpretazione delle istruzioni diversa per
    ciascuna parte da risolvere.

** Day 3

   Problema abbastanza noioso, sarà per via del wall-of-text?
   Insomma.

   Questi problemi dell'AoC che sembrano completamente artificiali
   sono risolti di solito da qualche algoritmo famoso che in questo
   caso mi sfugge.

   Avendo a che fare con il conteggio dei bit forse è collegato a
   qualche sistema di error-correction.

   Lo risolvo solo in python per il momento.

** Day 4
*** Parte 1

    Abbiamo una lista di numeri e delle schede del bingo da caricare
    in memoria e dobbiamo anche tenere traccia di quali numeri della
    scheda sono stati estratti.

    Il problema principale è determinare la struttura dati più adatta
    per rappresentare le schede e per risolvere il problema.

    Per la lista dei numeri la struttura è semplicemente un array.

    Per le schede proviamo ad usare due array:
    1) un array con 25 numeri per rappresentare i numeri sulla scheda.
    2) un array con 25 bool per segnare se il numero alla posizione
       corrispondente è stato estratto.

    Per mappare la posizione (x, y) => pos usiamo la formula:

    #+BEGIN_EXAMPLE
    pos = y * 5 + x
    #+END_EXAMPLE

    Viceversa per pos => (x, y):

    #+BEGIN_EXAMPLE
    x = pos % 5
    y = pos // 5
    #+END_EXAMPLE

    Ogni scheda inoltre ha un campo won che segnala se è già vincente:
    in questo caso anche se marchiamo un numero non è necessario
    ricalcolare se la scheda ha vinto.

    Una funzione mark(board, n) cerca nella scheda il numero n e se lo
    trova lo segna come estratto.

    Possiamo creare un'altra funzione check(board) per vedere se la
    scheda è vincente. Così facendo però dovremmo visitare tutte le
    colonne e tutte le righe.

    Invece possiamo effettuare il check solo sull'ultimo numero che è
    stato estratto, controllando la riga e la colonna cui appartiene.

    E' meglio quindi fondere mark() e check() in un'unica funzione
    mark_and_check() che:
    1) controlla se il numero è presente nella scheda e lo segna
       estratto.
    2) controlla se la riga del numero estratto è stata tutta estratta
    3) controlla se la colonna del numero estratto è stata tutta
       estratta
    4) restituisce un bool che indica se la scheda è vincente.

    In particolare il seguente codice python:

    #+BEGIN_SRC python
      self.won = self.won \
	  or self.check_row(pos) \
	  or self.check_column(pos)
    #+END_SRC

    sfrutta il cosiddetto short-circuiting dell'operatore *or*: se la
    prima condizione (self.won) è già *True* non elabora le condizioni
    successive.

    Per il calcolo dei punti (score) la struttura dei dati scelta
    risulta adatta: basta iterare per ogni numero della scheda,
    controllare se non è stato marcato e quindi sommarlo.

*** Parte 2

    Basta semplicemente eliminare dalla lista delle schede ogni scheda
    vincente finché non ne resta una sola. A questo punto si arriva al
    numero che fa vincere quest'ultima e si calcola lo score.

** Day 5
*** Parte 1

    Non sappiamo quanto grande è la mappa e quindi dovremo usare una
    sparse map (cioè una hash table / dizionario): a una coppia di
    coordinate corrisponderà il numero di vortici presenti.

    Creiamo una funzione draw(x0, y0, x1, y1) che aggiunge i vortici
    lungo i punti della linea.

    Il problema dice che le linee sono verticali o orizzontali e
    questo semplifica tutto perché basta incrementare le due variabili
    x0, y0 ad ogni iterazione del loop di una quantità costante (1, 0
    o -1): non succederà mai che una delle due coordinate aumenti più
    di un pixel per iterazione.

    Se le righe fossero state arbitrarie avremmo dovuto ricorrere ad
    algoritmi più complicati (Bresenham lineare).

    Bisogna solo determinare l'incremento ad ogni iterazione.

    Il codice può essere abbozzato come segue:

    #+BEGIN_SRC python
      def draw(x0, y0, x1, y1):
	  sx = x0 < x1 and 1 or (x0 > x1 and -1 or 0)
	  sy = y0 < y1 and 1 or (y0 > y1 and -1 or 0)

	  while True:
		  m[x0, y0] = m.get((x0, y0), 0) + 1
		  if x0 == x1 and y0 == y1:
			  break
		  x0 += sx
		  y0 += sy
    #+END_SRC

    La funzione draw dovrà essere chiamata solo per le righe
    orizzontali e verticali, cioè quelle in cui x0 == x1 oppure
    y0 == y1.

    Dopo aver disegnato ogni segmento sarà sufficiente contare gli
    elementi con valore > 1 iterando per ogni elemento del dizionario.

*** Parte 2

    Uguale alla parte 1 tranne che ora ci sono delle linee diagonali
    ma solo a 45°.

    Questa caratteristica ci garantisce che l'incremento per
    iterazione in entrambe le coordinate sia tra {1, 0, -1} e ci
    permette di riutilizzare la stessa procedura semplificata draw()
    vista sopra.

    Nella prima iterazione del codice controllavo che i segmenti
    fossero effettivamente a 45°: basta controllare che abs(x1-x0) ==
    abs(y1-y0).

    Poi, visto che non esistevano segmenti arbitrari nell'input, ho
    tolto il check.

** Day 6
*** Parte 1

    Il testo suggerisce che i pesci lanterna crescono in modo
    esponenziale e quindi un approccio esplicito non funzionerà.

    Nonostante l'indizio ho tentato inizialmente con un approccio
    esplicito, forse perché non ancora perfettamente sveglio: inutile
    dire che elencare ogni pesce in un array, anche se ordinato,
    sicuramente diventerà un disastro nella parte 2 del problema.

    Invece possiamo contare quanti pesci si riprodurranno in un
    determinato giorno.

    Con l'esempio di partenza 3,4,3,1,2:

    | giorno | numero pesci |
    |      1 |            0 |
    |      2 |            1 |
    |      3 |            1 |
    |      4 |            2 |
    |      5 |            1 |

    Il giorno 1 non c'è alcun pesce che si riproduce, quindi il totale
    dei pesci resta 5, la quantità iniziale.

    Il giorno 2 c'è un pesce che si riproduce quindi il totale dei
    pesci presenti il giorno 2 diventa 6 (5 + 1).

    Il pesce che si è riprodotto e il pesce neonato a loro volta si
    riprodurranno nei giorni futuri:

    | giorno | numero pesci |                                              |
    | 2 + 7  | pesci + 1    | il pesce si riproduce di nuovo               |
    | 2 + 9  | pesci + 1    | il pesce neonato si riproduce la prima volta |

    Perché aggiungiamo 7 e 9 anziché 6 e 8? Perché il testo suggerisce
    che il timer 0 è un valore valido, quindi in realtà trascorrono 7
    giorni e non 6 per la prossima riproduzione anche se il timer
    parte da 6.

    Passando al giorno 3: c'è un pesce che si riproduce quindi il
    totale arriva a 7 (6 + 1). Questo pesce si riprodurrà di nuovo il
    giorno 3 + 7 e il nuovo pesce si riprodurrà per la prima volta il
    giorno 3 + 9. Quindi aggiorniamo l'array della riproduzione dei
    pesci per i giorni 3 + 7 e 3 + 9.

    Passando al giorno 4: ci sono due pesci che si riproducono quindi
    il totale arriva a 9 (7 + 2). Questi due pesci si riprodurranno di
    nuovo nei giorni 4 + 7 e i due pesci neonati nei giorni
    4 + 9. Quindi aggiorniamo l'array della riproduzione dei pesci nei
    giorni 4 + 7 e 4 + 9 (con due pesci stavolta!).

    | giorno | numero pesci |                                             |
    | 4 + 7  | pesci + 2    | i due pesci si riproducono di nuovo         |
    | 4 + 9  | pesci + 2    | i due neonati si riproducono la prima volta |

    E così via fino ad arrivare al giorno 80.

    In pratica dobbiamo solo mantenere un array col numero di pesci
    che si riproducono per ogni giorno che passa, aggiornandolo giorno
    per giorno tenendo conto delle nuove nascite: la soluzione è
    programmazione dinamica.

    L'algoritmo è l'implementazione esatta della descrizione appena
    data con l'unica accortezza che il giorno 1 ha indice array
    pari 0 (quindi contiamo da 0 fino a 79 incluso).

    #+BEGIN_SRC python
      def solve(ages, days):
	  day = [0] * (days + 9)

	  for age in ages:
	      day[age] += 1

	  count = len(ages)
	  for i in range(days):
	      count += day[i]
	      day[i + 7] += day[i]
	      day[i + 9] += day[i]

	  return count
    #+END_SRC

*** Parte 2

    Identica alla parte 1 tranne che si arriva a 256 giorni anziché
    a 80.

    E' qui che si vede la potenza della programmazione dinamica:
    l'approccio esplicito sarebbe stato impossibile e il tempo di
    esecuzione improponibile.

    Invece l'algoritmo produce una soluzione in pochi millisecondi
    anche in python. In C e C++ la soluzione impiega meno di un
    millisecondo. Per evitare overflow ho usato interi unsigned a 64
    bit.

** Day 7
*** Parte 1

    Al di là del significato matematico del risultato che si vuole
    trovare il problema sembra di facile soluzione: per ogni posizione
    possibile calcoliamo il costo necessario a far convergere tutti i
    granchi a tale posizione.

    Il costo è il valore assoluto della differenza tra la posizione
    del granchio e la posizione scelta.

    Tra tutte le posizioni possibili scegliamo quella con costo più
    basso.

    L'implementazione impiega pochissimo anche in python, se c'è
    bisogno di una soluzione non brute-force lo vedremo nella parte 2.

*** Parte 2

    Come la parte 1 solo che cambia il calcolo del costo in carburante
    in funzione della distanza. In particolare, se la distanza è d il
    costo in carburante è la somma dei numeri naturali da 1 a d e
    cioè:

    #+BEGIN_EXAMPLE
    d * (d+1) / 2
    #+END_EXAMPLE

    [[https://it.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%C2%B7_%C2%B7_%C2%B7][Formula di Gauss]].

    Anche qui ci mette poco anche in python, inutile cercare soluzioni
    più elaborate.

    La soluzione C++, che usa le funzioni lambda a tutto spiano,
    impiega un tempo paragonabile alla soluzione C.

** Day 8
*** Parte 1

    La prima parte del problema è di facile soluzione in quanto
    consiste nel contare le parole con 2, 3, 4 e 7 caratteri.

*** Parte 2

    La seconda parte è più complicata perché dobbiamo determinare la
    corripondenza dei segmenti illuminati con le cifre.

    Dalla prima parte del problema sappiamo già associare a
    determinati segmenti determinate cifre:

    1) ai 2 caratteri corrisponde la cifra 1
    2) ai 3 caratteri corrisponde la cifra 7
    3) ai 4 caratteri corrisponde la cifra 4
    4) ai 7 caratteri corrisponde la cifra 8

    Rimane il problema di determinare quali sono gli altri caratteri e
    per farlo dobbiamo analizzare come sono rappresentati.

    Il primo problema da risolvere è la rappresentazione dei segmenti
    illuminati: ad esempio i segmenti "abcdefg" corrispondono a
    "gfedcba" e a tutte le sue permutazioni. Quindi abbiamo bisogno di
    un modo per rappresentare i segmenti che non tenga conto
    dell'ordine in cui appaiono le lettere.

    Per farlo ho usato una semplice bitmap calcolata come segue:

    #+BEGIN_SRC python
      letters = "abcdefg"

      def encode(lseg):
	  nseg = 0
	  for l in lseg:
	      nseg |= 1 << letters.index(l)
	  return nseg
    #+END_SRC

    In questo modo una sequenza di segmenti in lettere produce sempre
    lo stesso numero indipendentemente dal loro ordine. Si può
    ottenere lo stesso risultato ordinando le lettere o usando dei
    set.

    Per risolvere il problema è necessario contare quanti segmenti
    sono accesi. Nella rappresentazione letterale è semplice perché
    basta contare il numero dei caratteri. Per quella numerica bisogna
    contare il numero dei bit. Per farlo si possono usare le seguenti
    funzioni:

    #+BEGIN_SRC python
      def bitcount(i):
	  return bin(i).count("1")
    #+END_SRC

    In C/C++ si può usare l'intrinsic x86 popcnt() oppure la funzione
    di Kernighan:

    #+BEGIN_SRC c
      int bitcount(unsigned x)
      {
	      int count = 0;
	      while (x)
	      {
		      x &= x - 1;
		      count++;
	      }
	      return count;
      }
    #+END_SRC

    Tornando alla soluzione del problema possiamo partire dalla
    rappresentazione delle cifre in segmenti e precalcolare quanti
    segmenti accesi ha ogni cifra:

    | Cifra | Segmenti | Numero segmenti |
    |     0 | abcefg   |               6 |
    |     1 | cf       |               2 |
    |     2 | acdeg    |               5 |
    |     3 | acdfg    |               5 |
    |     4 | bcdf     |               4 |
    |     5 | abdfg    |               5 |
    |     6 | abdefg   |               6 |
    |     7 | acf      |               3 |
    |     8 | abcdefg  |               7 |
    |     9 | abdfg    |               6 |

    In questo modo quando mi imbatterò in una word di lunghezza 5 (ad
    esempio "cdfbe") saprò che ad essa potranno corrispondere le
    seguenti cifre: 2, 3, 5.

    Con una word di lunghezza 6 (ad esempio "cefabd") avremo le
    seguenti cifre possibili: 0, 6, 9.

    Ogni segmento letto viene quindi associato alle cifre potenziali
    che potrebbe rappresentare. Alcune cifre (1, 4, 7, e 8) avranno
    una lista di un solo elemento e sono quelle la cui
    rappresentazione è già determinata.

    Per il primo esempio del problema ottengo il seguente elenco (ho
    ordinato le lettere dei segmenti):

    | Cifra | Segmenti             | Determinata |
    |     0 | abcdef bcdefg abcdeg |             |
    |     1 | ab                   | *           |
    |     2 | bcdef acdfg abcdf    |             |
    |     3 | bcdef acdfg abcdf    |             |
    |     4 | abef                 | *           |
    |     5 | bcdef acdfg abcdf    |             |
    |     6 | abcdef bcdefg abcdeg |             |
    |     7 | abd                  | *           |
    |     8 | abcdefg              | *           |
    |     9 | abcdef bcdefg abcdeg |             |

    Rimane il problema di eliminare i segmenti sbagliati. Per farlo
    bisogna osservare la rappresentazione delle cifre: ad esempio
    osserviamo che la cifra 1, che ha normalmente rappresentazione
    "cf", ha in comune con la cifra 3 entrambi i segmenti (la cifra 3
    ha come normale rappresentazione "acdfg").

    Nel nostro esempio i collegamenti sono stati mescolati ma la
    proprietà deve rimanere, cioè la rappresentazione di 1 è "ab" e
    questi due segmenti devono entrambi essere presenti nella
    rappresentazione di 3.

    Ma se osserviamo i possibili candidati della cifra 3, i primi due
    hanno solo un segmento in comune con la cifra 1! Non possono
    rappresentare la cifra 3, perciò li eliminiamo.

    Risultato: la cifra 3 è associata al segmento "abcdf".

    | Cifra | Segmenti             | Determinata |
    |     0 | abcdef bcdefg abcdeg |             |
    |     1 | ab                   | *           |
    |     2 | bcdef acdfg abcdf    |             |
    |     3 | abcdf                | *           |
    |     4 | abef                 | *           |
    |     5 | bcdef acdfg abcdf    |             |
    |     6 | abcdef bcdefg abcdeg |             |
    |     7 | abd                  | *           |
    |     8 | abcdefg              | *           |
    |     9 | abcdef bcdefg abcdeg |             |

    Per lo stesso ragionamento sulla cifra 2 eliminiamo anche:
    * "bcdefg" dalla cifra 0 (deve avere 2 segmenti in comune)
    * "abcdf" dalla cifra 2 (deve avere 1 segmento in comune)
    * "abcdf" dalla cifra 5 (deve avere 1 segmento in comune)
    * "abcdef" e "abcdeg" dalla cifra 6 (deve avere 1 segmento in comune)
    * "bcdefg" dalla cifra 9 (deve avere due segmenti in comune)

    | Cifra | Segmenti      | Determinata |
    |     0 | abcdef abcdeg |             |
    |     1 | ab            | *           |
    |     2 | bcdef acdfg   |             |
    |     3 | abcdf         | *           |
    |     4 | abef          | *           |
    |     5 | bcdef acdfg   |             |
    |     6 | bcdefg        | *           |
    |     7 | abd           | *           |
    |     8 | abcdefg       | *           |
    |     9 | abcdef abcdeg |             |

    Ora procediamo con la cifra 3 che ha rappresentazione "abcdf", ed
    eliminiamo:
    * "abcdef" dalla cifra 0 (deve avere 4 segmenti comuni)
    * "abcdeg" dalla cifra 9 (deve avere 5 segmenti comuni)

    | Cifra | Segmenti    | Determinata |
    |     0 | abcdeg      | *           |
    |     1 | ab          | *           |
    |     2 | bcdef acdfg |             |
    |     3 | abcdf       | *           |
    |     4 | abef        | *           |
    |     5 | bcdef acdfg |             |
    |     6 | bcdefg      | *           |
    |     7 | abd         | *           |
    |     8 | abcdefg     | *           |
    |     9 | abcdef      | *           |

    Procediamo con la cifra 4 che ha rappresentazione "abef" ed
    eliminiamo:
    * "bcdef" dalla cifra 2 (deve avere 2 segmenti comuni)
    * "acdfg" dalla cifra 5 (deve avere 3 segmenti comuni)

    | Cifra | Segmenti | Determinata |
    |     0 | abcdeg   | *           |
    |     1 | ab       | *           |
    |     2 | acdfg    | *           |
    |     3 | abcdf    | *           |
    |     4 | abef     | *           |
    |     5 | bcdef    | *           |
    |     6 | bcdefg   | *           |
    |     7 | abd      | *           |
    |     8 | abcdefg  | *           |
    |     9 | abcdef   | *           |

    A questo punto abbiamo completato la mappatura da cifra ->
    segmenti e possiamo decifrare i numeri sul display:

    | Segmenti | Ordinati | Cifra |
    | cdfeb    | bcdef    |     5 |
    | fcadb    | abcdf    |     3 |
    | cdfeb    | bcdef    |     5 |
    | cdbaf    | abcdf    |     3 |


    Per eliminare i candidati abbiamo bisogno di una matrice che ci
    dica quanti segmenti in comune esistono tra due cifre arbitarie i
    e j, calcolando il numero degli elementi dell'intersezione dei
    segmenti.

    Questa matrice è di facile costruzione ed è simmetrica:

    #+BEGIN_EXAMPLE
    M[i][j] = bitcount(encode(seg[i]) & encode(seg[j]))
    #+END_EXAMPLE

    A questo punto è facile eliminare i candidati errati: se i è una
    cifra con una rappresentazione predeterminata e j ha più
    candidati, possiamo eliminare il candidato k in cui:

    #+BEGIN_EXAMPLE
    bitcount(seg[i] & seg[j][k]) != M[i][j]
    #+END_EXAMPLE

    Alla fine del procedimento di eliminazione, se il numero di
    candidati arriva a 1, abbiamo determinato la rappresentazione a
    segmenti della cifra.

    NOTA: per la prima soluzione del problema non ho usato questo
    approccio perché mi avrebbe portato via troppo tempo e ho
    preferito un brute-force con permutazioni, trovando la
    permutazione che generasse un elemento per ogni cifra.

    Poi con calma ho sviluppato il modo più ragionato.

** Day 9

*** Parte 1

    Creiamo la funzione risk(x, y) che calcola il rischio per
    l'elemento (x, y) della mappa.

    Controlliamo se ci sono vicini con valore minore e uguale
    all'elemento: in quel caso non è un punto di minimo e il rischio è
    zero.

    Se invece i vicini hanno valore maggiore dell'elemento, l'elemento
    è un punto di minimo con un rischio uguale a 1 + valore-elemento.

    Eseguiamo risk() per ogni elemento della mappa e sommandone i
    risultati otteniamo il rischio totale.

*** Parte 2

    Dobbiamo esplorare la mappa e lo possiamo fare con una Depth-First
    Search. Avremmo potuto usare anche una Breadth-First Search ma
    l'implementazione della DFS è più veloce.

    La funzione dfs(x, y) restituisce:
    * 0 se il valore in (x, y) == 9
    * 0 se (x, y) è già stato visitato da una ricerca precedente
    * n la dimensione del bacino in cui si trova (x,y).

    Per ogni punto della mappa chiamiamo dfs() e controlliamo il
    valore di ritorno: se è diverso da zero abbiamo trovato un nuovo
    bacino, con area pari al valore stesso. Questo valore è aggiunto
    ad un vettore.

    Al termine avremo un vettore con la dimensione di ogni bacino
    della mappa. Lo ordiniamo in ordine decrescente, prendiamo i primi
    3 valori della lista e li moltiplichiamo tra di loro.
