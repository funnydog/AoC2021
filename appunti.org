* Advent Of Code 2021

  I think it's time to blow this thing

  Get everybody and their stuff together

  Okay 3-2-1

  Let's jam... (cit)

** Day 1

*** Parte 1
    Prima parte molto semplice:
    1) il primo elemento viene assegnato alla variabile prev (previous,
       precedente).
    2) iteriamo dal secondo elemento all'ultimo confrontandolo con il
       prev e incrementando count se necessario.
    3) alla fine di ogni iterazione assegniamo a prev il valore
       corrente.

    Lo pseudo codice è il seguente:

    #+BEGIN_SRC python
    count = 0
    prev = depths[0]
      for cur in depths[1:]:
	 if prev < cur:
		 count += 1
	 prev = cur
    print(count)
    #+END_SRC

*** Parte 2
    Seconda parte abbastanza semplice, osservando che si tratta dello
    stesso algoritmo precedente ma applicato alla somma di tre elementi
    consecutivi.

    Possiamo calcolare la somma dei tre elementi con due loop annidati.

    Oppure possiamo calcolare solo la prima somma e aggiustarla con
    un'addizione e una sottrazione per ogni elemento successivo:

    #+BEGIN_EXAMPLE
    sum(i+1) = sum(i) - elemento(i + 3) - elemento(i)
    #+END_EXAMPLE

    Per un totale di n-2 somme.

    Ad un esame più approfondito noto che lo stesso ragionamento si
    può applicare per risolvere la parte 1, se la somma iniziale è di
    un solo elemento.

    Quindi possiamo usare lo stesso identico codice per entrambi i
    casi.

** Day2


*** Parte 1
    La prima parte è semplice, si tratta di interpretare correttamente
    tre istruzioni.

    La difficoltà maggiore è nel parsing dei dati: in python leggiamo
    il file intero con f.read()

    Applicando alla stringa ottenuta .splitlines() lo suddividiamo in
    linee.

    Dividiamo ogni stringa in due stringhe separate delimitate da spazi
    con .split().

    La prima stringa resta com'è, la seconda viene convertita in un
    numero intero. Codice Python:

    #+BEGIN_SRC python
    [(x[0], int(x[1])) for x in (x.split() for x in f.read().splitlines())]
    #+END_SRC

*** Parte 2
    La seconda parte è una variazione della prima con la modifica
    semantica delle istruzioni. Senza astrarre inutilmente il codice
    creo una funzione di interpretazione delle istruzioni diversa per
    ciascuna parte da risolvere.

** Day 3

   Problema abbastanza noioso, sarà per via del wall-of-text?
   Insomma.

   Questi problemi dell'AoC che sembrano completamente artificiali
   sono risolti di solito da qualche algoritmo famoso che in questo
   caso mi sfugge.

   Avendo a che fare con il conteggio dei bit forse è collegato a
   qualche sistema di error-correction.

   Lo risolvo solo in python per il momento.
